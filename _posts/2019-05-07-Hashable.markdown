---
layout: post
title:  "Hashable, Hasher - for types to be used in Set or Dictionary"
date:   2019-05-07 22:01:00
author: Dana Lee
categories: Swift 
tags:    Set Hashable Hasher hash Swift 
cover:  "/assets/instacode.png"
---



# Hashable, Hasher - for types to be used in Set or Dictionary

&nbsp;

#### :pushpin: Table Of Contents

- Set
- Hashable
- Hasher
- Conforming to the Hashable protocol

&nbsp;

&nbsp;

## Set 

> An unordered collection of unique elements

ì¤‘ë³µ ì—†ì´ uniqueí•œ ìš”ì†Œë“¤ë¡œë§Œ êµ¬ì„±ëœ ìˆœì„œ ì—†ëŠ” collection

&nbsp;

```swift
struct Set<Element> where Element : Hashable
```

- generic type ì¸ë°, type ì¤‘ì— Hashable protocolì„ ì±„íƒí•œ íƒ€ì…ë§Œ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ì˜ë¯¸

- ìœ„ì¹˜
  - _Foundation > Collections > Set_

- ì–¸ì œ ì‚¬ìš©í• ê¹Œ? (Array < Set ì¸ ê²½ìš°) ğŸ‘

  > You use a set instead of an array when you need to test efficiently for membership and you arenâ€™t concerned with the order of the elements in the collection, or when you need to ensure that each element appears only once in a collection

  - ìˆœì„œì— ìƒê´€ì—†ì´ ì†Œì†ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•  ë•Œ
  - ë”± í•œë²ˆë§Œ ë‚˜íƒ€ë‚˜ë„ë¡ í™•ì‹¤í•˜ê²Œ í•˜ê³  ì‹¶ì„ ë•Œ

- method

  - `contains`
  - `==` , `!==` (Equotable ì—ì„œ êµ¬í˜„ëœ method)
  - ì§‘í•© ì—°ì‚° : union, disjoint, subsetâ€¦ ë“±ë“±

- Set ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ê¸°ë³¸ ì¡°ê±´ : Set ì˜ elementê°€ ë˜ëŠ” typeì´ `Hashable` protocolì„ ì¤€ìˆ˜í•´ì•¼ í•œë‹¤.

&nbsp;

&nbsp;

## Hashable

```swift
protocol Hashable
```

> A type that can be hashed into a `Hasher` to produce an integer hash value

- `Hashable` protocolì„ ì¤€ìˆ˜í•˜ëŠ” type

  - Set, Dictionary keyë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” type 
  - í•´ë‹¹ typeì€ **integer hash valueë¥¼ ê°€ì§„ë‹¤**.

- standard library - Hashable ì±„íƒí•œ type

  - String
  - integer
  - floating-point
  - boolean .. etc

- hash valueê°€ í•„ìš”í•œ ì´ìœ  : :white_check_mark: **instanceë¥¼ íŒë³„í•˜ê³  êµ¬ë¶„í•˜ê³  ë¹„êµí•˜ê¸° ìœ„í•´ì„œ**

  - Hashable â‡¢ Equatable : Equatable protocolì„ ìƒì†ë°›ìŒ

    - Equatable protocol : a type that can be compared for value equality

      valueê°€ ì¼ì¹˜/ë¶ˆì¼ì¹˜ í•˜ëŠ”ì§€ `==`, `!==` operatorë¡œ ë¹„êµí•  ìˆ˜ ìˆëŠ” type

    - Hahableì€ ì´ëŸ° Equatable ì„ ìƒì†ë°›ì•˜ìœ¼ë¯€ë¡œ valueê°„ ë¹„êµê°€ ê°€ëŠ¥í•´ì•¼ í•œë‹¤

    - ë¹„êµ ëŒ€ìƒì€ hash valueê°€ ëœë‹¤.

  - Set, Dictionary ì˜ ê²½ìš°, ìˆœì„œê°€ ì—†ê¸° ë•Œë¬¸ì— ê° elementë¥¼ identify í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ í•„ìš” â†’ `hashValue`

  - ê°ê¸° ë‹¤ë¥¸ instance ë§ˆë‹¤ ê³ ìœ í•œ hash valueë¥¼ ê°–ë„ë¡ Hashable ì—ì„œ êµ¬í˜„ â†’ `hash(into:)`

- **'Hashing a value (ê°’ì„ í•´ì‹±í•œë‹¤)'** ì˜ ì˜ë¯¸

  - í•´ë‹¹ typeì˜ **essential components**(ê²°ì •ì ì¸ ë¶€ë¶„, ë‚¨ê³¼ ë‹¤ë¦„ì„ identify í•  ìˆ˜ ìˆëŠ” ë¶€ë¶„)ì„ hash functionì— ë„£ëŠ”ë‹¤ (Hasher type ì‚¬ìš©)
  - essential componentsëŠ” Equatable ì˜ êµ¬í˜„ì—ì„œ ì‚¬ìš©ëœ ë¶€ë¶„ì´ë‹¤. (ë¹„êµë¥¼ ìœ„í•´ì„œ ì‚¬ìš©ë˜ëŠ” ë¶€ë¶„)

- Hashable protocol - `hash(into: )` ì—ì„œ hash value ë§Œë“œëŠ” ë°©ë²•: `Hasher` ë¥¼ ì´ìš©

&nbsp;

&nbsp;

## Hasher

```swift
struct Hasher
```

> The universal hash function used by `Set` and `Dictionary`.
>
> `Hasher` can be used **to map an arbitrary sequence of bytes to an integer hash value**. You can feed data to the hasher using a series of calls to mutating `combine` methods. When youâ€™ve finished feeding the hasher, the hash value can be retrieved by calling `finalize()`

- byte sequence â†’ integer hash valueë¡œ ë³€í™˜í•´ì¤€ë‹¤.

- hash value ë§Œë“œëŠ” ë°©ë²• : mutating method`combine()` ì‚¬ìš©

  - combineìœ¼ë¡œ ë„˜ê¸´ ì¼ë ¨ì˜ ì¸ìì—ì„œ essential partë“¤ì„ haser state ì— ë„£ê³  ì„ìŒ
  - í”„ë¡œê·¸ë¨ í•œ ì‹¤í–‰ì—ì„œ ê°ê¸° ë‹¤ë¥¸ objectëŠ” ê°ì ë‹¤ë¥¸ hash valueë¥¼ ê°€ì§„ë‹¤.
  - í”„ë¡œê·¸ë¨ í•œ ì‹¤í–‰ì—ì„œ ê°™ì€ sequence of byteëŠ” í•­ìƒ ê°™ì€ hash valueë¥¼ ê°€ì§„ë‹¤.
  - haserëŠ” randomly seed ë˜ë¯€ë¡œ, ì—¬ëŸ¬ ë²ˆì˜ ì‹¤í–‰ì—ì„œ hash valueëŠ” ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤.
  - argumentì˜ typeì´ Hashable protocolì„ conformí•´ì•¼ í•œë‹¤.

- hash value ê°€ì ¸ì˜¤ëŠ” ë°©ë²•: function `finalize()` ì‚¬ìš©

  - haser stateë¥¼ ì¢…ë£Œí•˜ê³  hash valueë¥¼ ë°˜í™˜í•œë‹¤.

    > Finalizes the hasher state and returns the hash value.

&nbsp;

- _Example_

  ```swift
  var hasher = Hasher() //mutating method combine()ì„ ì‚¬ìš©í•˜ë ¤ë©´ varë¡œ ì„ ì–¸í•´ì•¼ í•¨
  hasher.combine(0)
  hasher.combine(1)
  print(hasher.finalize())
  // í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì‹œ ë§ˆë‹¤ hash valueê°€ ë‹¤ë¦„
  ```

  ```swift
  var hasher1 = Hasher() 
  var hasher2 = Hasher() 
  hasher1.combine(1)
  hasher2.combine(1)
  
  // ê°™ì€ hash valueë¥¼ ê°€ì§
  print(hasher1.finalize())
  print(hasher2.finalize())
  
  hasher2.combine(3)
  print(hasher2.finalize())
  // ë‹¤ë¥¸ hash value
  ```

&nbsp;

&nbsp;

## Conforming to the Hashable Protocol 

**Custom Typeì„ Set, Dictionary Keyì—ì„œ ì‚¬ìš©í•˜ë ¤ë©´, protocol Hashable ì„ ì¤€ìˆ˜í•´ì•¼ í•œë‹¤.**

> To customize your typeâ€™s `Hashable` conformance, to adopt `Hashable` in a type that doesnâ€™t meet the criteria listed above, or to extend an existing type to conform to `Hashable`, implement the `hash(into:)` method in your custom type.

#### Ways to Conform Hashable Protocol

##### 1. ìë™ìœ¼ë¡œ ë”°ë¥´ëŠ” ê²½ìš°

- struct
  - ëª¨ë“  stored propertyê°€ Hashable ì¤€ìˆ˜í•˜ëŠ” ê²½ìš°
- enum
  - With associated value: í•´ë‹¹ value typeì´ Hashable ì¤€ìˆ˜í•˜ëŠ” ê²½ìš°
  - without assiciated value: ì„ ì–¸ ì—†ì´ë„ ìë™ìœ¼ë¡œ Hashable ì¤€ìˆ˜

##### 2. ì§ì ‘ conformanceë¥¼ ë‹¤ë¤„ì•¼ í•˜ëŠ” ê²½ìš°

- 3ê°€ì§€ ê²½ìš°
  - 1ë²ˆì˜ ìë™ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í•˜ëŠ” ê²½ìš°
  - existing type ì´ Hashable ì„ ì±„íƒí•˜ë ¤ëŠ” ê²½ìš°
  - Hashable conformanceë¥¼ ì§ì ‘ custom í•˜ë ¤ëŠ” ê²½ìš°
- ë°©ë²• : í•´ë‹¹ typeì— `hash(into:)` method êµ¬í˜„
- `hash(into:)` êµ¬í˜„í•˜ê¸°
  - Haserì˜ `combine(_:)` - argumentì— í•´ë‹¹ typeì˜ essential componentë¥¼ ë„˜ê²¨ì¤€ë‹¤.
  - Equatable conformanceë¥¼ ë‹¤ì‹œ êµ¬í˜„í•˜ëŠ” ê²ƒë„ ê¶Œì¥ë¨ 

&nbsp;

- _Example - ì¢Œí‘œ ìƒì˜ ì ì„ ë‚˜íƒ€ë‚´ëŠ” struct MyPoint_

  ```swift
  struct MyPoint {
    private(set) var x: Int = 0
    private(set) var y: Int = 0
    
    //.. initializer...
  }
  
  extension MyPoint: Hashable {
    static func ==(lpoint: MyPoint, rpoint: MyPoint) -> Bool {
      return lpoint.x == rpoint.x && lpoint.y == rpoint.y
    }
    
    func hash(into haser: inout Hasher) {
      //using essential components - x, y
      haser.combine(x) 
      haser.combine(y) 
    }
  }
  ```

  



