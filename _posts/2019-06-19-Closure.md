---
layout: post
title:  "Closure in Swift - ê¸°ëŠ¥ì„ ê°€ì§„ ì½”ë“œ ë¸”ëŸ­"
date:  2019-06-19 17:32:59
author: Dana Lee
categories: Swift
tags: Closure
lastmod : 2019-06-26 20:13:59
sitemap :
  changefreq : weekly
  priority : 1.0
---

# Closure in Swift

> Closure : ê¸°ëŠ¥ì„ ê°€ì§„ ì½”ë“œ ë¸”ë¡<br>
> Self-contained blocks of functionality 



Closures can capture and store references to any constants and variable from *the context in which they are defined.*

 í´ë¡œì ¸ëŠ” ìì‹ ì´ ì •ì˜ëœ ê³³ì˜ ìƒìˆ˜ì™€ ë³€ìˆ˜ì— ëŒ€í•œ reference ë¥¼ capture, store í•  ìˆ˜ ìˆë‹¤. 

This is known as *closing over* this constants and variables.

 ìƒìˆ˜ì™€ ë³€ìˆ˜ë¥¼ ê°€ë‘”ë‹¤(close over) ëŠ” ì˜ë¯¸ì´ë‹¤.

&nbsp;

í•¨ìˆ˜(Functions)ë„ í´ë¡œì ¸ì— í¬í•¨ë˜ëŠ” ê°œë…ì´ë‹¤. (í´ë¡œì ¸ > í•¨ìˆ˜) í•¨ìˆ˜ëŠ” íŠ¹ë³„í•œ í´ë¡œì ¸ ì¼€ì´ìŠ¤ì´ë‹¤.

ì´ë¦„ì´ ìˆëŠ” í´ë¡œì ¸ë¥¼ í•¨ìˆ˜ë¼ê³  í•œë‹¤.

&nbsp;

ğŸ“ í´ë¡œì ¸ì˜ í˜•ì‹ 3ê°€ì§€

1. Global functions 
   - ì´ë¦„ì„ ê°€ì§
   - ì–´ë–¤ value ë„ ìº¡ì³ ì•ˆí•¨
   
2. Nested functions (í•¨ìˆ˜ ì•ˆì—ì„œ ì •ì˜ëœ í•¨ìˆ˜)
   - ì´ë¦„ ìˆìŒ
   - nested functionì„ ê°ì‹¸ëŠ” function ë‚´ë¶€ì˜ valueë¥¼ ìº¡ì³í•  ìˆ˜ ìˆìŒ 
   
   ```swift
   func outer() {
   	func inner() { // <- Nested function
   		...
   	}
   }
   ```
   
3. Closures
   - ì´ë¦„ ì—†ìŒ
   - í´ë¡œì €ê°€ ì„ ì–¸ëœ context ì£¼ë³€ì˜ valueë¥¼ ìº¡ì³í•  ìˆ˜ ìˆë‹¤

| í˜•ì‹            | ì´ë¦„ | capturing value               |
| --------------- | ---- | ----------------------------- |
| Global function | ìˆìŒ | ì•ˆí•¨                          |
| nested function | ìˆìŒ | enclosing function ë‚´ë¶€ value |
| closure         | ì—†ìŒ | ì„ ì–¸ëœ ê³³ context ì˜ value    |

&nbsp;

## Closure Expressions

Nested function ë„ ì¢€ ë” í° function ì—ì„œ ê¸°ëŠ¥ì„ ê°–ëŠ” ì½”ë“œ ë¸”ëŸ­ì„ ë„¤ì´ë°í•˜ëŠ” ì¢‹ì€ ë°©ë²•ì´ë‹¤.

í•˜ì§€ë§Œ ì„ ì–¸ê³¼ ì´ë¦„ ì—†ì´ ë” ì§§ì€ í˜•íƒœì˜ í•¨ìˆ˜ê°™ì€ ê¸°ëŠ¥ì„ í•˜ëŠ” ì½”ë“œ ë¸”ëŸ­ì„ ë§Œë“¤ê³  ì‹¶ë‹¤ë©´ í´ë¡œì ¸ê°€ ì¢‹ì€ ë°©ë²•ì´ ëœë‹¤.

### Syntax

```swift
{ (parmeters) -> return_type in
	statements
}
```

ì„ ì–¸ë¶€ì™€ êµ¬í˜„ë¶€ë¥¼ `in` ê¸°ì¤€ìœ¼ë¡œ êµ¬ë¶„

&nbsp;

### Sorted Method

- Swift standard library ê°€ ì œê³µí•˜ëŠ” method

- array ì˜ value ë“¤ì„ ì „ë‹¬ë°›ì€ sorting closure ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ì—¬, ì •ë ¬ëœ ìƒˆë¡œìš´ ë°°ì—´ì„ return í•´ì¤Œ. 
- ì›ë˜ ë°°ì—´ì€ ë³€ë™ ì—†ìŒ

- (higher order function)
- ì¸ìë¡œ ë°›ëŠ” í´ë¡œì ¸ê°€ íŒë‹¨í•˜ëŠ” ë°” 
  - ì²«ë²ˆì§¸ ê°’ì´ ë‘ë²ˆì§¸ ê°’ë³´ë‹¤ ë¨¼ì € ë‚˜ì˜¤ë©´ true
  - ascending (s1 < s2) , descending(s1 > s2)

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

func backward(_ s1: String, _ s2: String) -> Bool {
  return s1 > s2
}

var reversedNames = name.sorted(by: backward)
// ["Ewa", "Daniella", "Chris", "Barry", "Alex"]

var reversedNamesUsingClosure = name.sorted(by: {
  (s1: String, s2: String) -> Bool in
  return s1 > s2
})
```



- Inferring Type from Context

  - array element ë¥¼ ì¸ìë¡œ ë°›ëŠ” í´ë¡œì ¸ë‹ˆê¹Œ, Swiftê°€ Inferring Type ê°€ëŠ¥
  - String ìƒëµ ê°€ëŠ¥

  ```swift
  reversedNames = name.sorted(by: { (s1, s2) -> Bool in return s1 > s2})
  ```

- Single-Expression Closure ì¼ ê²½ìš°, return ìƒëµ ê°€ëŠ¥

  - í´ë¡œì ¸ ë°”ë””(`in` ë’·ë¶€ë¶„)ê°€ í•œì¤„ì´ë©´, implicitly return í•œë‹¤ê³  íŒë‹¨í•¨

  ```swift
  reversedNames = name.sorted(by: { (s1, s2) -> Bool in s1 > s2})
  ```

- Shorthand Argument Names

  - ì¸ì ì´ë¦„ë„ ì§€ì • ì•ˆí•˜ê³  `$0`ì²˜ëŸ¼ ì‚¬ìš©ê°€ëŠ¥
  - ì´ë¦„ ì„ ì–¸ ì•ˆí•˜ë©´, `in` keyword ë„ í•„ìš” ì—†ìŒ

  ```
  reversedNames = name.sorted(by: { $0 > $1 })
  ```

- Operator Methods

  - `>` operator : **ì§€ì • ì—°ì‚°ì**ë¡œ `String` type ì— êµ¬í˜„ë˜ì–´ ìˆìŒ 
  - `>` ìì²´ê°€ ì‚¬ì‹¤ì€ method ì´ë¯€ë¡œ, ë¶€ë“±í˜¸ë§Œ ì¸ìë¡œ ë„˜ê²¨ë„ ê°€ëŠ¥

  ```swift
  reversedNames = name.sorted(by: >)
  ```

&nbsp;

## Trailing Closure 

í•¨ìˆ˜ì˜ ë§ˆì§€ë§‰ ì¸ìë¡œ í´ë¡œì ¸ë¥¼ ë„˜ê¸°ëŠ” ê²½ìš°, í´ë¡œì ¸ë¥¼ êµ³ì´ `()`(argument list) ì•ˆì— ì“°ì§€ ì•Šì•„ë„ ë¨

- ê´„í˜¸ ë’¤ë¶€í„° `{}`ì‚¬ìš©í•˜ê¸°

  ```swift
  reversedNames = name.sorted() { $0 > $1 }
  ```

- ì¸ìê°€ í´ë¡œì ¸ ë‹¨ë…ì´ë¼ë©´, `()`ë„ ìƒëµ ê°€ëŠ¥

  ```
  reversedNames = name.sorteds{ $0 > $1 }
  ```

- í´ë¡œì ¸ ë°”ë””ê°€ ê¸´ ê²½ìš°ì— ê°€ë…ì„± ë†’ì¼ ìˆ˜ ìˆìŒ

- *Example* : Swift Array `map(_:)` method 

  - ìˆ«ì ë°›ì•„ì„œ ê° ìë¦¬ì— ë§ëŠ” string í•©ì³ì„œ ë°˜í™˜í•˜ê¸°
  - ì¼ì˜ ìë¦¬ë¶€í„° (%10) (ë’¤ì—ì„œ ì•ìœ¼ë¡œ)

  ```swift
  let digitNames = [
      0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
      5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
  ]
  let numbers = [16, 58, 510]
  
  let numberStrings = numbers.map { (num) -> String in
    var num = num
    var output = ""
    repeat {
      output = digitNames[num % 10]! + output
      num = num / 10
    } while num > 0
    return output                               
  }
  //["OneSix", "FiveEight", "FiveOneZero"]
  ```

  - dictionary lookup with subscript returns optional â†’ need exclamation mark(`!`)

&nbsp;

## Capturing Value

> A closure can *capture* constants and variables from the surrounding context in which it is defined. The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.

closure ëŠ” ì •ì˜ëœ ê³³ì˜ surrouding context ì— ìˆëŠ” variable & constant ë¥¼ capture í•œë‹¤.

í´ë¡œì ¸ ì•ˆì—ì„œ ê·¸ ë³€ìˆ˜, ìƒìˆ˜ì˜ ê°’ì„ ì°¸ì¡°í•˜ê³ , ìˆ˜ì •í•  ìˆ˜ ìˆë‹¤.

original scope ì´ ë” ì´ìƒ ì¡´ì¬í•˜ì§€ ì•Šì•„ë„ í´ë¡œì ¸ ì•ˆì—ì„œ ì‚¬ìš© ê°€ëŠ¥ â†’ ê·¸ë˜ì„œ capture í•œë‹¤ê³  í•¨

&nbsp;

- nested function : swiftì—ì„œ í´ë¡œì ¸ê°€ capture value í•˜ëŠ” ëŒ€í‘œì ì¸ ì˜ˆ

- nested function ì€ outer functionì˜ ì¸ì, ë³€ìˆ˜ ìƒìˆ˜ ë‹¤ capture ê°€ëŠ¥

- *Example* : ì£¼ì–´ì§„ ìˆ˜ ë§Œí¼, increment ë˜ë„ë¡ í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë°˜í™˜

  - outer function : í•¨ìˆ˜ ë§Œë“¤ê¸°
  - nested function : amount ë§Œí¼ ì¦ê°€ì‹œí‚¨ ìˆ˜ë¥¼ ë°˜í™˜

  ```swift
  func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
      runningTotal += amount
      return runningTotal
    }
    return incrementer
  }
  ```

  - nested function(incrementer()) ëŠ” outer function ì˜ `runningTotal` ë³€ìˆ˜ë¥¼ capture
  - `runningTotal` ë³€ìˆ˜ë¥¼ ì°¸ì¡°í•˜ê³  ê·¸ ê°’ì„ amount ë§Œí¼ ì¦ê°€ì‹œí‚´
  - `makeIncrementer` í•¨ìˆ˜ê°€ return í•˜ê³  ì¢…ë£Œí•´ë„ ë°˜í™˜ëœ í•¨ìˆ˜ëŠ” ì—¬ì „íˆ `runningTotal` ì„ ì°¸ì¡°í•˜ê³  ê°’ì„ ë°”ê¿€ ìˆ˜ ìˆìŒ

  ```swift
  let incrementByTen = makeIncrementer(forIncrement: 10)
  
  incrementByTen()
  // 10
  incrementByTen()
  // 20
  incrementByTen()
  // 30
  
  let incrementBySeven = makeIncrementer(forIncrement: 7)
  
  incrementBySeven()
  // 7
  incrementByTen()
  // 40
  ```

  - ìƒì„±ë  ë  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ `runningTotal` ì„ ì°¸ì¡°í•˜ëŠ” ê²ƒì´ë¯€ë¡œ `incrementBySeven` ì€ `incrementByTen` ê³¼ëŠ” ë‹¤ë¥¸ ë³€ìˆ˜ë¥¼ ì°¸ì¡°í•¨

&nbsp;

## Closures Are Reference Types

caputuring value ê°€ ê°€ëŠ¥í•œ ì´ìœ  : closureê°€ reference type ì´ê¸° ë•Œë¬¸

í´ë¡œì ¸ë‚˜ í•¨ìˆ˜ë¥¼ ì–´ë–¤ variable or constant ì— í• ë‹¹í•˜ëŠ” ê²ƒì€ ê·¸ referenceë¥¼ í• ë‹¹í•˜ëŠ” ê²ƒ

- ì•ì˜ ì˜ˆì—ì„œ `incerementByTen` ì€ í´ë¡œì ¸ content ê·¸ ìì²´ë¥¼ ê°€ì§€ê³  ìˆëŠ”ê²Œ ì•„ë‹ˆê³  reference ë§Œ ê°€ì§€ê³  ìˆëŠ” ê²ƒ

- ì„œë¡œ ë‹¤ë¥¸ ë³€ìˆ˜ë‚˜ ìƒìˆ˜ê°€ ê°™ì€ closure ë¥¼ ì°¸ì¡°í•  ìˆ˜ ìˆìŒ

  ```swift
  let anotherReference = incrementByTen
  anotherReference()
  // 50
  ```

&nbsp;

## Escaping Closure

function ì˜ ì¸ìë¡œ ë„˜ê²¨ì§„ í´ë¡œì ¸ê°€, ê·¸ functionì´ return ëœ í›„ì— í˜¸ì¶œ(call)ë  ë•Œ, í•¨ìˆ˜ë¥¼ escape í•œë‹¤(escape a function) ë¼ê³  í•¨

- escape í•˜ëŠ” ì¸ì ì•ì— `@escaping` ë¶™ì´ë©´ ë¨

- function ë°–ì—ì„œ ì„ ì–¸ëœ ë³€ìˆ˜ì— í´ë¡œì ¸ê°€ ì €ì¥ë˜ëŠ” ê²½ìš°  - escape function í•˜ëŠ” ì˜ˆ

  ```swift
  var completionHandlers: [() -> Void] = []
  func functionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
  }
  ```

  - function ë°–ì—ì„œ ì„ ì–¸ëœ ë³€ìˆ˜ `completionHandlers` ì— ì¸ìë¡œ ë°›ì€ í´ë¡œì ¸ê°€ ì €ì¥ëœë‹¤.
  - ì´ í´ë¡œì ¸ëŠ” ì¸ìë¡œ ë„˜ê²¨ì§„ í•¨ìˆ˜ê°€ return ëœ í›„ì—ë„ ì‚¬ìš©ë˜ì–´ì•¼ í•˜ë¯€ë¡œ `@escaping` í•„ìš”
  - ëª…ì‹œ ì•ˆí•˜ë©´ ì»´íŒŒì¼ ì—ëŸ¬ ë‚¨

- `@escaping` ë¥¼ ëª…ì‹œí•´ì¤€ë‹¤ == í´ë¡œì ¸ì—ì„œ `self` ë¥¼ ëª…ì‹œì (explicitly)ìœ¼ë¡œ ì°¸ì¡°í•œë‹¤.

  ```swift
  var completionHandlers: [() -> Void] = []
  func functionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
  }
  
  func functionWithNonescapingClosure(closure: () -> Void) {
      closure()
  }
  
  class SomeClass {
      var x = 10
      func doSomething() {
          functionWithEscapingClosure { self.x = 100 }
          functionWithNonescapingClosure { x = 200 }
      }
  }
  
  let instance = SomeClass()
  instance.doSomething()
  print(instance.x)
  // Prints "200"
  
  completionHandlers.first?()
  print(instance.x)
  // Prints "100"
  ```

  - `functionWithNonescapingClosure` ëŠ” `self` ë¥¼ ì•”ë¬µì ìœ¼ë¡œ ì°¸ì¡°í•œë‹¤.
  - í´ë¡œì ¸ì—ì„œ `self` ë¥¼ ì‚¬ìš©í•œë‹¤ë©´ `@escaping` í•„ìš”

&nbsp;

## Autoclosures

> An *autoclosure* is a closure that is automatically created to wrap an expression thatâ€™s being passed as an argument to a function.

- function argument ë¡œ ë„˜ê¸¸ í´ë¡œì ¸ë¥¼ ìë™ìœ¼ë¡œ ë§Œë“¤ì–´ ì¤Œ (`{}` ì—†ì´ ë„˜ê²¨ë„ í´ë¡œì ¸ê°€ ë¨)

- í•¨ìˆ˜ ì¸ìë¡œ ë„˜ê¸°ëŠ” ë¶€ë¶„ì— í‘œí˜„ì„ ì§ì ‘ ì¨ ë„£ëŠ” ë°©ë²•

- autoclosure ëŠ” argument ì—†ê³ , í˜¸ì¶œì‹œ ë‚´ë¶€ í‘œí˜„ ê°’ì„ return í•œë‹¤ â†’ single-line expression ê°€ëŠ¥

- autoclosure ë¥¼ ì¸ìë¡œ ë°›ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ê±´ í”í•¨

- ê·¸ëŸ° í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ëŠ” ê±´ ì•ˆ í”í•¨. 

- `@autoclosure` keyword ëª…ì‹œ

- Example

  ```swift
  var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
  print(customersInLine.count)
  // Prints "5"
  
  let customerProvider = { customersInLine.remove(at: 0) }
  print(customersInLine.count)
  // Prints "5"
  
  print("Now serving \(customerProvider())!")
  // Prints "Now serving Chris!"
  print(customersInLine.count)
  // Prints "4"
  ```

  - customerProvider í˜¸ì¶œ ë˜ê¸° ì „ê¹Œì§„ ë°°ì—´ ìš”ì†Œ ì¤„ì–´ë“¤ì§€ ì•ŠìŒ
  - serving í•˜ëŠ” ë¶€ë¶„ì„ ë‹´ì€ í•¨ìˆ˜ë¥¼ ë§Œë“¤ê¸°

  ```swift
  // customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]
  func serve(customer customerProvider: () -> String) {
      print("Now serving \(customerProvider())!")
  }
  serve(customer: { customersInLine.remove(at: 0) } )
  // Prints "Now serving Alex!"
  ```

  - ì¸ìë¥¼ autoclosure ë¥¼ ë°›ëŠ”ë‹¤ê³  í—ˆìš©í•˜ë©´ `{}`ë„ í•„ìš” ì—†ìŒ

  ```swift
  // customersInLine is ["Ewa", "Barry", "Daniella"]
  func serve(customer customerProvider: @autoclosure () -> String) {
      print("Now serving \(customerProvider())!")
  }
  serve(customer: customersInLine.remove(at: 0)) //autoclosure
  // Prints "Now serving Ewa!"
  ```

  - autoclosure, escaping ê°™ì´ ì‚¬ìš©ê°€ëŠ¥

  ```swift
  // customersInLine is ["Barry", "Daniella"]
  var customerProviders: [() -> String] = []
  func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {
      customerProviders.append(customerProvider)
  }
  collectCustomerProviders(customersInLine.remove(at: 0))
  collectCustomerProviders(customersInLine.remove(at: 0))
  
  print("Collected \(customerProviders.count) closures.")
  // Prints "Collected 2 closures."
  for customerProvider in customerProviders {
      print("Now serving \(customerProvider())!")
  }
  // Prints "Now serving Barry!"
  // Prints "Now serving Daniella!"
  ```

&nbsp;

## Reference

[Swift Language Guide - Closure](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)